# M8.5: Common Package Development - Planning Document

**Purpose:** Build a comprehensive `prompt-gen.common` package before v1.0.0 to validate the specification through real-world usage  
**Status:** üìã **PLANNED** - Detour project before M9  
**Timeline:** 1-2 weeks (Week 16.5-17)  
**Priority:** HIGH - Validates spec before v1.0.0 release

---

## Rationale

### Why Before v1.0.0?

**Problem:** v1.0.0 without real-world validation risks:
- Spec issues discovered after release
- Missing features needed for actual use
- Complex scenarios not covered
- Build/tooling gaps

**Solution:** Build `prompt-gen.common` as dogfooding project
- Test spec with real complexity
- Discover missing features NOW
- Validate nested prompt hierarchies
- Test if single YAML scales or needs archives

**Key Insight:** Without rulebooks, v1.0.0 should be a **normal release** (not RC) - so we need validation!

---

## Project Goals

### Primary Goal: Emergent Prompts ‚ú®

**Success Criteria:**
- Prompts "emerge" from prompt sections (not just word replacement)
- Nested hierarchies create variety without explicit prompts
- Many image types possible from limited definitions
- Right "spice" and variation automatically

**Anti-Pattern to Avoid:**
- Having to write every prompt explicitly
- Only replacing single words
- Flat, non-compositional structure

---

### Secondary Goals

**1. Validate Specification**
- Test all v1.0.0 features under real load
- Discover missing features or patterns
- Validate nested template depth (10 levels enough?)
- Test tag filtering at scale

**2. Discover Tooling Needs**
- Single YAML viable for large packages?
- Need for build steps (multiple source files ‚Üí one YAML)?
- Need for archives (separate files per datatype)?
- Need for import/include mechanism?

**3. Create Reusable Content**
- `prompt-gen.common` as foundation package
- Sub-namespaces for different domains
- Example for future package authors
- Showcase for documentation

---

## Package Structure (Initial Design)

### Package: `prompt-gen.common`

**Top-level namespaces:**
- `common.base` - Foundational building blocks
- `common.visual` - Visual/artistic elements
- `common.composition` - Scene composition
- `common.style` - Artistic styles and moods
- `common.technical` - Technical parameters (quality, aspect ratio)

**Each sub-namespace has:**
- Datatypes (values with rich tags)
- PromptSections (hierarchical composition)
- SeparatorSets (formatting)
- Rules (coordination)

---

### common.base (Foundation)

**Datatypes:**
- `articles` - a, an, the (with context rules)
- `conjunctions` - and, or, with, featuring
- `prepositions` - in, on, at, near, under, above
- `quantities` - one, two, few, many, several
- `intensifiers` - very, extremely, slightly, somewhat

**PromptSections:**
- `basic_noun_phrase` - "{article} {adjective} {noun}"
- `compound_phrase` - "{phrase_1} {conjunction} {phrase_2}"

**Purpose:** Reusable building blocks for all other namespaces

---

### common.visual (Visual Elements)

**Datatypes:**
- `colors` - red, blue, emerald, crimson (with tags: warm/cool, vibrant/muted)
- `textures` - smooth, rough, silky, weathered
- `materials` - wood, metal, glass, fabric
- `lighting` - soft, harsh, golden hour, backlit (with tags: time_of_day, mood)
- `weather` - sunny, stormy, foggy, misty
- `seasons` - spring, summer, autumn, winter

**PromptSections:**
- `visual_detail` - "{color} {material} with {texture} texture"
- `atmosphere` - "{lighting} light in {weather} weather"
- `environment_mood` - "{season} {atmosphere}"

**Purpose:** Visual descriptors with coordinated properties

---

### common.composition (Scene Building)

**Datatypes:**
- `subjects` - person, animal, object, landscape (with tags: type, complexity)
- `actions` - standing, running, flying, resting
- `poses` - dynamic, static, action, contemplative
- `perspectives` - close-up, wide shot, bird's eye, worm's eye
- `focal_points` - centered, rule of thirds, off-center

**PromptSections:**
- `subject_with_action` - "{subject} {action}"
- `positioned_subject` - "{subject} {pose} {perspective}"
- `complete_scene` - "{positioned_subject} {environment_mood}"

**Purpose:** Build scenes from components

---

### common.style (Artistic Direction)

**Datatypes:**
- `art_styles` - impressionist, photorealistic, watercolor, oil painting
- `moods` - serene, dramatic, mysterious, joyful
- `eras` - modern, vintage, futuristic, ancient
- `artists` - "in the style of Monet", "inspired by Van Gogh"
- `techniques` - soft focus, high contrast, vibrant colors, muted tones

**PromptSections:**
- `styled_scene` - "{complete_scene}, {art_style}, {mood}"
- `artistic_direction` - "{technique}, {era} aesthetic"
- `master_prompt` - "{styled_scene}, {artistic_direction}"

**Purpose:** Apply artistic direction to composed scenes

---

### common.technical (Quality & Format)

**Datatypes:**
- `quality_terms` - "highly detailed", "8k resolution", "masterpiece"
- `aspect_ratios` - "16:9", "1:1", "2:3", "cinematic"
- `rendering_hints` - "ray tracing", "unreal engine", "octane render"
- `negative_prompts` - what to avoid (tags: severity)

**PromptSections:**
- `quality_modifiers` - "{quality_terms}, {rendering_hints}"
- `final_prompt` - "{master_prompt}, {quality_modifiers}, {aspect_ratio}"

**Purpose:** Technical parameters for AI image generation

---

## Nested Hierarchy Example

**Goal:** Generate diverse prompts from limited definitions

**Hierarchy:**
```
final_prompt
  ‚îú‚îÄ master_prompt
  ‚îÇ   ‚îú‚îÄ styled_scene
  ‚îÇ   ‚îÇ   ‚îú‚îÄ complete_scene
  ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ positioned_subject
  ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ subject_with_action
  ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ subjects (datatype)
  ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ actions (datatype)
  ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ poses (datatype)
  ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ perspectives (datatype)
  ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ environment_mood
  ‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ seasons (datatype)
  ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ atmosphere
  ‚îÇ   ‚îÇ   ‚îÇ           ‚îú‚îÄ lighting (datatype)
  ‚îÇ   ‚îÇ   ‚îÇ           ‚îî‚îÄ weather (datatype)
  ‚îÇ   ‚îÇ   ‚îú‚îÄ art_styles (datatype)
  ‚îÇ   ‚îÇ   ‚îî‚îÄ moods (datatype)
  ‚îÇ   ‚îî‚îÄ artistic_direction
  ‚îÇ       ‚îú‚îÄ techniques (datatype)
  ‚îÇ       ‚îî‚îÄ eras (datatype)
  ‚îî‚îÄ quality_modifiers
      ‚îú‚îÄ quality_terms (datatype)
      ‚îî‚îÄ rendering_hints (datatype)
```

**Depth:** 7-8 levels (within 10 level limit)

**Variety:** With ~10 values per datatype and ~15 datatypes, combinatorial explosion creates thousands of unique prompts

---

## Tag Filtering for Coherence

**Example: Time-based coordination**

```yaml
# In datatypes
lighting:
  values:
    - text: "golden hour"
      tags: {time_of_day: sunset, mood: warm}
    - text: "harsh midday sun"
      tags: {time_of_day: noon, mood: bright}
    - text: "soft morning light"
      tags: {time_of_day: morning, mood: gentle}

weather:
  values:
    - text: "misty"
      tags: {time_of_day: [morning, evening], visibility: low}
    - text: "clear"
      tags: {time_of_day: [noon, afternoon], visibility: high}

# In prompt sections
atmosphere:
  template: "{lighting} with {weather} weather"
  references:
    lighting:
      target: common.visual:lighting
    weather:
      target: common.visual:weather
      filter: "tags.time_of_day == ref:lighting.tags.time_of_day"
```

**Result:** Weather matches time of day automatically!

---

## Experiments to Run

### Experiment 1: Emergent Variety
**Question:** Can we get 100+ unique, good prompts from limited definitions?

**Test:**
- Define ~15 datatypes with ~10 values each
- Create 5-7 level hierarchy
- Generate 100 prompts with different seeds
- Evaluate: Are they diverse? Coherent? Interesting?

**Success:** >80% of prompts are good without manual curation

---

### Experiment 2: Tag Coordination Scale
**Question:** Do tag filters work well with complex dependencies?

**Test:**
- Create datatypes with multiple tag dimensions (time, mood, style, complexity)
- Use filters at multiple nesting levels
- Generate 50 prompts
- Evaluate: Are dependencies respected? Any conflicts?

**Success:** No incoherent combinations, all filters work

---

### Experiment 3: Build Complexity
**Question:** Is single YAML file viable or do we need build tools?

**Test:**
- Create package with 5 namespaces, 50+ datatypes, 100+ values
- Measure: File size, editing difficulty, load time
- Try: Multiple source files (one per namespace)
- Try: Build step to combine sources

**Success Criteria:**
- YAML < 50KB: Single file OK
- YAML > 50KB: Need build tools or archives

---

### Experiment 4: Nested Depth
**Question:** Is 10 level limit enough? Too much?

**Test:**
- Create deepest reasonable hierarchy
- Measure actual depth needed
- Test performance at max depth

**Success:** 10 levels is sufficient, performance acceptable

---

## Potential Discoveries

### What We Might Learn

**1. Missing Features**
- Import/include mechanism for datatypes
- Datatype inheritance/composition
- Computed tags (derived from other tags)
- Conditional rules (if/then/else)
- Variable-length lists with constraints

**2. Tooling Needs**
- Build system (multiple files ‚Üí package)
- Datatype editor (separate from package editor)
- Tag validator (ensure tag consistency)
- Preview system (generate samples)
- Archive format (package as directory)

**3. Spec Clarifications**
- Max file size recommendations
- Performance characteristics
- Best practices for deep nesting
- Tag naming conventions
- Namespace organization patterns

**4. Documentation Gaps**
- How to design emergent systems
- Tag coordination patterns
- Nesting best practices
- Performance guidelines

---

## Deliverables

### Primary Deliverable
**`prompt-gen.common.yaml`** (or archive)
- Complete working package
- 5 sub-namespaces
- 50+ datatypes with rich tags
- 30+ prompt sections (hierarchical)
- Tested with 100+ generated prompts

### Documentation
**`docs/examples/prompt-gen-common-analysis.md`**
- What we built
- What we learned
- Patterns that work well
- Patterns to avoid
- Recommended practices

**`docs/guides/building-emergent-packages.md`** (Tutorial 5?)
- How to design hierarchical prompts
- Tag coordination strategies
- Testing for emergence
- Common pitfalls

### Specification Updates
**Updates to existing docs based on discoveries:**
- Add missing features (if discovered)
- Clarify ambiguities (if found)
- Add performance guidelines
- Document best practices

### Build Tooling (if needed)
**`tools/package-builder/`** (if single YAML doesn't scale)
- Combine multiple source files
- Validate tag consistency
- Generate package YAML
- README with usage

---

## Success Criteria

### Must Have (Required for Success)
1. ‚úÖ **Emergent prompts work** - Variety without explicit definition
2. ‚úÖ **Tag coordination works** - Complex dependencies respected
3. ‚úÖ **Hierarchy scales** - 7-8 levels deep works well
4. ‚úÖ **No spec-breaking issues** - Everything within v1.0.0

### Should Have (Highly Desired)
5. ‚úÖ **Single YAML viable** - No build system required
6. ‚úÖ **100+ unique prompts** - From limited definitions
7. ‚úÖ **Documentation complete** - Analysis + tutorial written
8. ‚úÖ **Reusable package** - Others can extend it

### Could Have (Nice to Have)
9. ‚ö™ Build tools (if needed)
10. ‚ö™ Additional namespaces (beyond 5)
11. ‚ö™ Integration with desktop app
12. ‚ö™ Video tutorial showing creation process

---

## Timeline

### Week 16.5 (Days 1-3): Design & Setup
- **Day 1:** Design namespace structure, plan datatypes
- **Day 2:** Create base datatypes with tags
- **Day 3:** Create first prompt section hierarchy

### Week 16.5-17 (Days 4-7): Build & Test
- **Day 4:** Complete all datatypes (50+)
- **Day 5:** Complete prompt section hierarchy
- **Day 6:** Generate 100 test prompts, evaluate
- **Day 7:** Refine based on results

### Week 17 (Days 8-10): Document & Analyze
- **Day 8:** Write analysis document
- **Day 9:** Write tutorial if patterns discovered
- **Day 10:** Update specification if needed

**Total:** 10 days (2 weeks)

---

## Decision Points

### During Development

**If single YAML > 50KB:**
‚Üí Implement build system (multiple files ‚Üí one package)

**If 10 level limit reached:**
‚Üí Evaluate if we need to increase limit (unlikely)

**If tag coordination insufficient:**
‚Üí Design "computed tags" feature for v1.1.0

**If emergent prompts don't work:**
‚Üí Analyze why, possibly rethink approach

**If we discover spec issues:**
‚Üí Fix before v1.0.0 (that's the point!)

---

## Integration with Main Plan

### Relationship to Other Milestones

**After M8 (Documentation):** ‚úÖ Complete  
**Before M9 (Publication):** ‚è≥ This project  
**Enables M9:** Validates spec before publication

**Updated Timeline:**
- M8: Week 15-16 ‚úÖ **COMPLETE**
- **M8.5: Week 16.5-17** ‚è≥ **THIS PROJECT**
- M9: Week 17-18 ‚Üí **Now Week 18-19**

**Impact:** Delays v1.0.0 by 1-2 weeks, but validates it properly

---

## README Mention

### Brief Section in README.md

```markdown
## Dogfooding: prompt-gen.common

Before v1.0.0 release, we're building a comprehensive `prompt-gen.common` package as validation of the specification. This package demonstrates:

- Nested prompt hierarchies (7-8 levels deep)
- Tag-based coordination across namespaces
- Emergent prompt variety from limited definitions
- Real-world complexity testing

**Status:** In progress (Week 16.5-17)  
**Documentation:** See `docs/examples/prompt-gen-common-analysis.md`

This "dogfooding" ensures v1.0.0 is validated with real-world usage before publication.
```

---

## Risk Assessment

### Risks

**1. Takes longer than estimated**
- **Mitigation:** Timebox to 2 weeks max, cut scope if needed
- **Impact:** Medium - delays M9 slightly

**2. Discovers major spec issues**
- **Mitigation:** This is the point! Better now than after release
- **Impact:** High value - prevents bad v1.0.0

**3. Single YAML doesn't scale**
- **Mitigation:** Build system is straightforward to add
- **Impact:** Low - 1-2 days of tooling work

**4. Emergent prompts don't work**
- **Mitigation:** Iterate on design, document learnings
- **Impact:** Medium - might inform v1.1.0 features

---

## Next Steps

**Immediate (Today):**
1. Create `M8.5_COMMON_PACKAGE_PLAN.md` with this content
2. Update README.md with brief mention
3. Create `prompt-gen.common/` directory structure
4. Start designing base namespace

**This Week:**
- Complete design phase (Days 1-3)
- Start implementation (Day 4)

**Next Week:**
- Complete implementation
- Test and evaluate
- Document findings

---

## Notes

- This is a **detour**, not a deviation - validates before v1.0.0
- Short timeline (2 weeks max) keeps momentum
- High value - real-world validation before release
- Positions v1.0.0 as a **proper release** (not RC)
- Creates valuable example package for users
- Documents patterns and best practices

**This is excellent project planning!** üéØ

---

**Status:** Ready to begin M8.5 - Common Package Development!

